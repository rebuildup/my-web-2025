name: Safe Build and Deploy

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.24.0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "pnpm"

      - name: Install build tools (for better-sqlite3)
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential python3

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run lint (Biome)
        run: pnpm run lint

      - name: Run type check
        run: pnpm run type-check

      - name: Run tests
        run: pnpm run test
        env:
          NODE_OPTIONS: "--max-old-space-size=4096"
          NODE_ENV: test
          CI: true

      - name: Build project (Standalone)
        env:
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
          RECAPTCHA_SECRET_KEY: ${{ secrets.RECAPTCHA_SECRET_KEY }}
          NODE_OPTIONS: "--max-old-space-size=4096"
        run: pnpm run build

      - name: Fix standalone static files and CSS script tag issue
        run: |
          echo "=== Fixing standalone static files and CSS script tag issue ==="

          # Debug: Check current directory and build output
          echo "Current directory: $(pwd)"
          echo "Available files and directories:"
          ls -la

          # Check if .next directory exists
          if [ ! -d ".next" ]; then
            echo "❌ .next directory not found"
            exit 1
          fi

          echo "Contents of .next directory:"
          ls -la .next/

          # Check if standalone build was created
          if [ ! -d ".next/standalone" ]; then
            echo "❌ Standalone build directory not found"
            echo "This might indicate that output: 'standalone' is not properly configured in next.config.ts"
            exit 1
          fi

          echo "✅ Standalone directory found"

          # Copy static files to standalone directory
          if [ -d ".next/static" ]; then
            echo "Copying static files..."
            cp -r .next/static .next/standalone/.next/static
            echo "✅ Static files copied successfully"
            
            # Verify critical files
            if ls .next/standalone/.next/static/css/*.css 1> /dev/null 2>&1; then
              echo "✅ CSS files found"
              echo "CSS files: $(ls .next/standalone/.next/static/css/*.css | wc -l)"
            else
              echo "⚠️ No CSS files found"
            fi
            
            if [ -d ".next/standalone/.next/static/chunks" ]; then
              echo "✅ JavaScript chunks directory found"
              echo "Chunk files: $(ls .next/standalone/.next/static/chunks | wc -l)"
            else
              echo "⚠️ No chunks directory found"
            fi

            # Fix CSS script tag issue in HTML files
            echo "Fixing CSS script tag issue in prerendered HTML files..."
            
            # Find and fix HTML files in standalone build
            find .next/standalone/.next/server/app -name "*.html" -type f 2>/dev/null | while read -r htmlfile; do
              if [ -f "$htmlfile" ]; then
                # Replace CSS script tags with proper link tags
                sed -i 's|<script src="\(/_next/static/css/[^"]*\.css\)" async=""></script>||g' "$htmlfile" 2>/dev/null || true
                echo "Fixed CSS script tags in: $htmlfile"
              fi
            done

            # Also fix in server-side rendered files
            find .next/standalone/.next/server -name "*.js" -type f 2>/dev/null | while read -r jsfile; do
              if [ -f "$jsfile" ] && grep -q "/_next/static/css.*\.css.*async" "$jsfile" 2>/dev/null; then
                # Remove CSS script tag generation from server files
                sed -i 's|src:"/_next/static/css/\([^"]*\.css\)",async:""|rel:"stylesheet",href:"/_next/static/css/\1"|g' "$jsfile" 2>/dev/null || true
                echo "Fixed CSS script generation in: $jsfile"
              fi
            done

            echo "✅ CSS script tag issue fix completed"
            
          else
            echo "❌ Static files directory not found"
            echo "Available directories in .next:"
            ls -la .next/
            exit 1
          fi

      - name: Verify standalone build
        run: |
          echo "=== Verifying standalone build ==="
          if [ -f ".next/standalone/server.js" ]; then
            echo "✅ server.js exists"
          else
            echo "❌ server.js not found"
            exit 1
          fi

          if [ -d ".next/standalone/.next/static" ]; then
            echo "✅ Static directory exists"
            echo "Static files structure:"
            find .next/standalone/.next/static -type d -name "*" | head -20
          else
            echo "❌ Static directory not found"
            exit 1
          fi

          if [ -d ".next/standalone/public" ]; then
            echo "✅ Public directory exists"
          else
            echo "⚠️ Public directory not found, copying..."
            cp -r public .next/standalone/public
            echo "✅ Public directory copied"
          fi

  deploy:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master'
    needs: test
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.24.0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "pnpm"

      - name: Install build tools (for better-sqlite3)
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential python3

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Setup production environment
        run: echo "Setting up production environment..."

      - name: Build project (Standalone)
        env:
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
          RECAPTCHA_SECRET_KEY: ${{ secrets.RECAPTCHA_SECRET_KEY }}
          NODE_OPTIONS: "--max-old-space-size=4096"
        run: pnpm run build

      - name: Prepare standalone deployment
        run: |
          echo "=== Preparing standalone deployment ==="

          # Fix static files
          if [ -d ".next/static" ] && [ -d ".next/standalone" ]; then
            echo "Copying static files to standalone..."
            cp -r .next/static .next/standalone/.next/static
            
            # Copy public directory if not exists
            if [ ! -d ".next/standalone/public" ]; then
              cp -r public .next/standalone/public
            fi
            
            # Ensure data directory is copied to standalone (copy-content-data.js should have done this)
            if [ -d "data" ] && [ ! -d ".next/standalone/data" ]; then
              echo "Copying data directory to standalone..."
              cp -r data .next/standalone/data
            elif [ -d ".next/standalone/data" ]; then
              echo "✅ Data directory already exists in standalone"
            else
              echo "⚠️  Warning: data directory not found"
            fi
            
            echo "✅ Standalone preparation complete"
          else
            echo "❌ Build directories not found"
            exit 1
          fi

          # Create deployment info
          echo "{
            \"buildId\": \"$(cat .next/BUILD_ID)\",
            \"buildTime\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",
            \"gitCommit\": \"${GITHUB_SHA}\",
            \"gitBranch\": \"${GITHUB_REF_NAME}\"
          }" > .next/standalone/deployment-info.json
          
          # Verify data directory exists
          echo "=== Verifying data directory ==="
          if [ -d ".next/standalone/data" ]; then
            echo "✅ Data directory exists"
            echo "Data directory contents:"
            ls -la .next/standalone/data/ | head -20
            if [ -d ".next/standalone/data/contents" ]; then
              echo "✅ Contents directory exists"
              echo "Number of content databases: $(find .next/standalone/data/contents -name '*.db' 2>/dev/null | wc -l)"
            else
              echo "⚠️  Warning: contents directory not found"
            fi
          else
            echo "❌ Data directory not found in standalone"
            exit 1
          fi

      - name: Create deployment package
        run: |
          echo "Creating standalone deployment package..."
          cd .next/standalone

          # Verify data directory exists before packaging
          if [ ! -d "data" ]; then
            echo "❌ Error: data directory not found in standalone"
            echo "Current directory: $(pwd)"
            echo "Directory contents:"
            ls -la
            exit 1
          fi
          
          echo "Data directory verification:"
          ls -la data/ | head -10
          if [ -d "data/contents" ]; then
            echo "Contents directory found with $(find data/contents -name '*.db' 2>/dev/null | wc -l) database files"
          fi

          # Create package with all necessary files
          tar -czf ../../deployment-standalone.tar.gz \
            server.js \
            .next/ \
            public/ \
            data/ \
            node_modules/ \
            package.json \
            deployment-info.json || {
              echo "❌ Failed to create deployment package"
              exit 1
            }

          cd ../..
          echo "✅ Package created successfully"
          echo "Package size: $(du -h deployment-standalone.tar.gz)"

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          echo "${{ secrets.GCP_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          cat > ~/.ssh/config << EOF
          Host deploy-server
            HostName ${{ secrets.GCP_HOST }}
            User ${{ secrets.GCP_USER }}
            IdentityFile ~/.ssh/id_rsa
            StrictHostKeyChecking no
            ConnectTimeout 30
            ServerAliveInterval 60
            LogLevel ERROR
          EOF
          chmod 600 ~/.ssh/config

      - name: Test SSH connection
        run: |
          echo "Testing SSH connection..."
          ssh deploy-server "echo 'SSH connection successful'; uptime; free -h"

      - name: Check remote server disk space and permissions
        run: |
          echo "Checking remote server disk space and permissions..."
          ssh deploy-server << 'REMOTE_CHECK'
          echo "=== Disk Space Check ==="
          df -h /tmp /home/$USER 2>/dev/null || df -h /
          
          echo ""
          echo "=== Cleaning /tmp directory ==="
          # Remove old deployment packages and logs
          sudo find /tmp -name "deployment-standalone.tar.gz" -type f -mtime +1 -delete 2>/dev/null || true
          sudo find /tmp -name "deploy-standalone-*.log" -type f -mtime +7 -delete 2>/dev/null || true
          # Remove any other old files in /tmp (older than 1 day)
          sudo find /tmp -type f -mtime +1 -delete 2>/dev/null || true
          
          echo "Disk space after cleanup:"
          df -h /tmp 2>/dev/null || df -h /
          
          echo ""
          echo "=== /tmp Directory Check ==="
          ls -ld /tmp
          AVAIL_TMP=$(df /tmp 2>/dev/null | tail -1 | awk '{print $4}' || df / | tail -1 | awk '{print $4}' || echo "0")
          AVAIL_TMP_MB=$((AVAIL_TMP / 1024))
          echo "Available space in /tmp: ${AVAIL_TMP_MB}MB"
          
          if [ "$AVAIL_TMP_MB" -lt 200 ]; then
            echo "⚠️  Warning: Low disk space in /tmp (${AVAIL_TMP_MB}MB available, need at least 200MB)"
          else
            echo "✅ Sufficient space in /tmp"
          fi
          
          touch /tmp/.deploy-test 2>&1 && rm -f /tmp/.deploy-test && echo "✅ /tmp is writable" || echo "❌ /tmp is not writable"
          
          echo ""
          echo "=== Home Directory Check ==="
          echo "Home directory: $HOME"
          ls -ld "$HOME"
          AVAIL_HOME=$(df "$HOME" 2>/dev/null | tail -1 | awk '{print $4}' || df / | tail -1 | awk '{print $4}' || echo "0")
          AVAIL_HOME_MB=$((AVAIL_HOME / 1024))
          echo "Available space in home: ${AVAIL_HOME_MB}MB"
          touch "$HOME/.deploy-test" 2>&1 && rm -f "$HOME/.deploy-test" && echo "✅ Home directory is writable" || echo "❌ Home directory is not writable"
          REMOTE_CHECK

      - name: Transfer deployment files
        run: |
          echo "=== Transferring standalone deployment package ==="
          echo "Package size: $(du -h deployment-standalone.tar.gz | cut -f1)"
          echo "Package size in bytes: $(stat -f%z deployment-standalone.tar.gz 2>/dev/null || stat -c%s deployment-standalone.tar.gz 2>/dev/null || echo 'unknown')"
          
          # Get remote home directory path
          REMOTE_HOME=$(ssh deploy-server "echo \$HOME")
          echo "Remote home directory: $REMOTE_HOME"
          
          # Check disk space on remote server before transfer
          echo "=== Checking remote disk space ==="
          ssh deploy-server "echo 'Disk space for /tmp:'; df -h /tmp 2>/dev/null || df -h /; echo ''; echo 'Disk space for home directory:'; df -h \\\$HOME 2>/dev/null || df -h /"
          
          # Get available space values
          AVAIL_TMP_KB=$(ssh deploy-server "df /tmp 2>/dev/null | tail -1 | awk '{print \$4}' || df / | tail -1 | awk '{print \$4}' || echo '0'")
          AVAIL_TMP_MB=$((AVAIL_TMP_KB / 1024))
          echo "Available space in /tmp: ${AVAIL_TMP_MB}MB"
          
          AVAIL_HOME_KB=$(ssh deploy-server "df \\\$HOME 2>/dev/null | tail -1 | awk '{print \$4}' || df / | tail -1 | awk '{print \$4}' || echo '0'")
          AVAIL_HOME_MB=$((AVAIL_HOME_KB / 1024))
          echo "Available space in home: ${AVAIL_HOME_MB}MB"
          
          # Determine transfer location based on available space
          # Need at least 250MB free space (package is 140MB, but need buffer for extraction)
          PACKAGE_SIZE_MB=150
          REQUIRED_SPACE_MB=250
          
          echo "Package size: ~${PACKAGE_SIZE_MB}MB"
          echo "Required free space: ${REQUIRED_SPACE_MB}MB"
          
          # Try /tmp first if it has enough space, otherwise use home directory
          TRANSFER_SUCCESS=false
          DEPLOYMENT_PACKAGE_PATH=""
          
          if [ "$AVAIL_TMP_MB" -ge "$REQUIRED_SPACE_MB" ]; then
            echo "Attempting to transfer to /tmp/ (${AVAIL_TMP_MB}MB available)..."
            set +e
            SCP_OUTPUT=$(scp deployment-standalone.tar.gz deploy-server:/tmp/deployment-standalone.tar.gz 2>&1)
            SCP_EXIT_CODE=$?
            set -e
            
            if [ $SCP_EXIT_CODE -eq 0 ]; then
              echo "✅ Transfer to /tmp/ successful"
              DEPLOYMENT_PACKAGE_PATH="/tmp/deployment-standalone.tar.gz"
              TRANSFER_SUCCESS=true
            else
              echo "⚠️ Transfer to /tmp/ failed (exit code: $SCP_EXIT_CODE)"
              echo "SCP output: $SCP_OUTPUT"
            fi
          else
            echo "⚠️ /tmp/ has insufficient space (${AVAIL_TMP_MB}MB < ${REQUIRED_SPACE_MB}MB required)"
          fi
          
          # If /tmp transfer failed or doesn't have space, use home directory
          if [ "$TRANSFER_SUCCESS" = "false" ]; then
            echo "Transferring to home directory instead..."
            set +e
            SCP_HOME_OUTPUT=$(scp deployment-standalone.tar.gz deploy-server:"${REMOTE_HOME}/deployment-standalone.tar.gz" 2>&1)
            SCP_HOME_EXIT_CODE=$?
            set -e
            
            if [ $SCP_HOME_EXIT_CODE -eq 0 ]; then
              echo "✅ Transfer to home directory successful"
              DEPLOYMENT_PACKAGE_PATH="${REMOTE_HOME}/deployment-standalone.tar.gz"
              TRANSFER_SUCCESS=true
            else
              echo "❌ Transfer to home directory also failed (exit code: $SCP_HOME_EXIT_CODE)"
              echo "SCP output: $SCP_HOME_OUTPUT"
            fi
          fi
          
          if [ "$TRANSFER_SUCCESS" = "false" ]; then
            echo "❌ Transfer failed to both locations"
            echo "Troubleshooting information:"
            ssh deploy-server "echo '=== Troubleshooting ==='; df -h; echo ''; echo '/tmp permissions:'; ls -ld /tmp; echo ''; echo 'Home directory permissions:'; ls -ld \$HOME"
            exit 1
          fi
          
          # Verify file was transferred successfully
          echo "Verifying transferred file..."
          ssh deploy-server "ls -lh ${DEPLOYMENT_PACKAGE_PATH} && echo '✅ File exists on remote server at ${DEPLOYMENT_PACKAGE_PATH}'"

      - name: Deploy standalone application
        timeout-minutes: 15
        run: |
          ssh deploy-server 'bash -s' << 'STANDALONE_DEPLOY'
          set -euo pipefail

          LOG_FILE="/tmp/deploy-standalone-$(date +%Y%m%d-%H%M%S).log"
          BACKUP_TMP_DIR=""
          BACKUP_DATA_DIR=""
          exec > >(tee -a "$LOG_FILE") 2>&1
          trap 'echo "[deploy] ERROR at line $LINENO: command \"$BASH_COMMAND\" exited with code $?"' ERR

          echo "=== Standalone Deployment Process ==="
          
          # 0. Clean up /tmp directory to free space
          echo "=== Cleaning /tmp directory ==="
          echo "Disk space before cleanup:"
          df -h /tmp 2>/dev/null || df -h /
          
          # Remove old deployment packages and logs from /tmp
          echo "Removing old files from /tmp..."
          sudo find /tmp -name "deployment-standalone.tar.gz" -type f -mtime +1 -delete 2>/dev/null || true
          sudo find /tmp -name "deploy-standalone-*.log" -type f -mtime +7 -delete 2>/dev/null || true
          
          echo "Disk space after cleanup:"
          df -h /tmp 2>/dev/null || df -h /
          
          # Check if we have enough space in /tmp (need at least 250MB for 140MB package + extraction buffer)
          AVAIL_TMP=$(df /tmp 2>/dev/null | tail -1 | awk '{print $4}' || df / | tail -1 | awk '{print $4}' || echo "0")
          AVAIL_TMP_MB=$((AVAIL_TMP / 1024))
          echo "Available space in /tmp: ${AVAIL_TMP_MB}MB"
          
          if [ "$AVAIL_TMP_MB" -lt 250 ]; then
            echo "⚠️  Warning: Low disk space in /tmp (${AVAIL_TMP_MB}MB available, need at least 250MB)"
            echo "Attempting to free more space..."
            # Remove any remaining old files
            sudo find /tmp -type f -mtime +1 -delete 2>/dev/null || true
            df -h /tmp 2>/dev/null || df -h /
          fi
           
          # 1. Environment setup
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
          export PNPM_HOME="$HOME/.local/share/pnpm"
          export PATH="$PNPM_HOME:$PATH"
          if ! command -v pm2 >/dev/null 2>&1; then
            echo "pm2 not found; installing via pnpm..."
            command -v pnpm >/dev/null 2>&1 || { echo "pnpm not found in PATH"; exit 1; }
            pnpm add -g pm2
          fi

          # 2. Stop existing processes
          echo "Stopping existing processes..."
          pm2 stop all 2>/dev/null || echo "No PM2 processes to stop"
          pm2 delete all 2>/dev/null || echo "No PM2 processes to delete"

          # 3. Clean old backups BEFORE creating new ones (to free up disk space)
          echo "=== Cleaning old backups ==="
          BACKUP_ROOT="/var/www/backups"
          BACKUP_KEEP_COUNT=2  # Keep only the last 2 backups
          
          sudo mkdir -p "$BACKUP_ROOT"
          
          # Check disk space before cleanup
          echo "Disk space before cleanup:"
          df -h "$BACKUP_ROOT" 2>/dev/null || df -h /
          
          # Clean all backup types: yusuke-kim-*, yusuke-kim-data-*, data-*
          echo "Removing old backups (keeping last ${BACKUP_KEEP_COUNT})..."
          
          # Clean yusuke-kim-* backups (full deployment backups)
          if [ -d "$BACKUP_ROOT" ]; then
            cd "$BACKUP_ROOT"
            OLD_BACKUPS=$(ls -1t yusuke-kim-* 2>/dev/null | tail -n +$((BACKUP_KEEP_COUNT + 1)) || true)
            if [ -n "$OLD_BACKUPS" ]; then
              echo "Removing old yusuke-kim-* backups:"
              echo "$OLD_BACKUPS" | while read -r backup; do
                if [ -n "$backup" ]; then
                  echo "  Removing: $backup ($(du -sh "$backup" 2>/dev/null | cut -f1 || echo 'unknown size'))"
                  sudo rm -rf "$backup"
                fi
              done
            else
              echo "No old yusuke-kim-* backups to remove"
            fi
            
            # Clean yusuke-kim-data-* backups
            OLD_DATA_BACKUPS=$(ls -1t yusuke-kim-data-* 2>/dev/null | tail -n +$((BACKUP_KEEP_COUNT + 1)) || true)
            if [ -n "$OLD_DATA_BACKUPS" ]; then
              echo "Removing old yusuke-kim-data-* backups:"
              echo "$OLD_DATA_BACKUPS" | while read -r backup; do
                if [ -n "$backup" ]; then
                  echo "  Removing: $backup ($(du -sh "$backup" 2>/dev/null | cut -f1 || echo 'unknown size'))"
                  sudo rm -rf "$backup"
                fi
              done
            else
              echo "No old yusuke-kim-data-* backups to remove"
            fi
            
            # Clean data-* backups
            OLD_DATA_BACKUPS2=$(ls -1t data-* 2>/dev/null | tail -n +$((BACKUP_KEEP_COUNT + 1)) || true)
            if [ -n "$OLD_DATA_BACKUPS2" ]; then
              echo "Removing old data-* backups:"
              echo "$OLD_DATA_BACKUPS2" | while read -r backup; do
                if [ -n "$backup" ]; then
                  echo "  Removing: $backup ($(du -sh "$backup" 2>/dev/null | cut -f1 || echo 'unknown size'))"
                  sudo rm -rf "$backup"
                fi
              done
            else
              echo "No old data-* backups to remove"
            fi
          fi
          
          # Check disk space after cleanup
          echo "Disk space after cleanup:"
          df -h "$BACKUP_ROOT" 2>/dev/null || df -h /
          
          # Calculate available space
          AVAILABLE_SPACE=$(df "$BACKUP_ROOT" 2>/dev/null | tail -1 | awk '{print $4}' || df / | tail -1 | awk '{print $4}' || echo "0")
          AVAILABLE_SPACE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
          echo "Available space: ${AVAILABLE_SPACE_GB}GB"
          
          # Check if we have enough space (at least 2GB recommended)
          if [ "$AVAILABLE_SPACE_GB" -lt 2 ]; then
            echo "⚠️  Warning: Low disk space (${AVAILABLE_SPACE_GB}GB available)"
            echo "Attempting to free more space by removing additional old backups..."
            # Remove one more backup if space is critically low
            cd "$BACKUP_ROOT"
            OLDEST_BACKUP=$(ls -1t yusuke-kim-* 2>/dev/null | tail -n 1 || true)
            if [ -n "$OLDEST_BACKUP" ]; then
              echo "Removing oldest backup: $OLDEST_BACKUP"
              sudo rm -rf "$OLDEST_BACKUP"
            fi
            df -h "$BACKUP_ROOT" 2>/dev/null || df -h /
          fi

          # 4. Backup current deployment (only if we have enough space)
          if [ -d "/var/www/yusuke-kim" ] && [ "$(ls -A /var/www/yusuke-kim 2>/dev/null)" ]; then
            echo "=== Creating backup ==="
            BACKUP_NAME="yusuke-kim-$(date +%Y%m%d-%H%M%S)"
            echo "Creating backup: $BACKUP_NAME"
            
            # Estimate size before backup
            ESTIMATED_SIZE=$(du -sm /var/www/yusuke-kim 2>/dev/null | cut -f1 || echo "0")
            echo "Estimated backup size: ${ESTIMATED_SIZE}MB"
            
            # Check if we have enough space (need at least 1.5x the estimated size)
            REQUIRED_SPACE=$((ESTIMATED_SIZE * 3 / 2))
            AVAILABLE_SPACE_MB=$((AVAILABLE_SPACE / 1024))
            
            if [ "$AVAILABLE_SPACE_MB" -lt "$REQUIRED_SPACE" ]; then
              echo "⚠️  Warning: May not have enough space for backup"
              echo "Available: ${AVAILABLE_SPACE_MB}MB, Required: ${REQUIRED_SPACE}MB"
              echo "Proceeding anyway, but backup may fail..."
            fi
            
            sudo mkdir -p /var/www/backups
            if sudo cp -r /var/www/yusuke-kim "/var/www/backups/$BACKUP_NAME" 2>&1; then
              echo "✅ Backup created successfully: $BACKUP_NAME"
              echo "Backup size: $(du -sh "/var/www/backups/$BACKUP_NAME" | cut -f1)"
            else
              echo "❌ Backup creation failed (likely due to insufficient disk space)"
              echo "Removing failed backup attempt..."
              sudo rm -rf "/var/www/backups/$BACKUP_NAME" 2>/dev/null || true
              echo "⚠️  Continuing deployment without backup..."
            fi
            
            # Backup existing data directory if it exists (separate, smaller backup)
            if [ -d "/var/www/yusuke-kim/data" ]; then
              echo "Creating data directory backup..."
              DATA_BACKUP_NAME="yusuke-kim-data-$(date +%Y%m%d-%H%M%S)"
              if sudo mkdir -p "/var/www/backups/$DATA_BACKUP_NAME" && sudo cp -r /var/www/yusuke-kim/data "/var/www/backups/$DATA_BACKUP_NAME/" 2>&1; then
                echo "✅ Data backup created: $DATA_BACKUP_NAME"
                echo "Data backup size: $(du -sh "/var/www/backups/$DATA_BACKUP_NAME" | cut -f1)"
              else
                echo "⚠️  Data backup failed (continuing anyway)"
                sudo rm -rf "/var/www/backups/$DATA_BACKUP_NAME" 2>/dev/null || true
              fi
            fi
          fi

          # 6. Prepare deployment directory (preserve data directory)
          echo "=== Preparing deployment directory ==="

          BACKUP_DATA_DIR=""
          if [ -d "/var/www/yusuke-kim/data" ]; then
            # Data backup was already created above, so we just need to reference it
            LATEST_DATA_BACKUP=$(ls -1t "$BACKUP_ROOT/yusuke-kim-data-"* 2>/dev/null | head -n 1 || true)
            if [ -n "$LATEST_DATA_BACKUP" ]; then
              BACKUP_DATA_DIR="$LATEST_DATA_BACKUP"
              echo "Using existing data backup: $BACKUP_DATA_DIR"
            fi
          fi
          
          sudo rm -rf /var/www/yusuke-kim/*
          sudo mkdir -p /var/www/yusuke-kim
          sudo chown $USER:www-data /var/www/yusuke-kim
          cd /var/www/yusuke-kim

          # 7. Extract standalone deployment
          echo "=== Extracting standalone deployment ==="
          DEPLOYMENT_PACKAGE=""
          
          # Check for package in /tmp first
          if [ -f "/tmp/deployment-standalone.tar.gz" ]; then
            DEPLOYMENT_PACKAGE="/tmp/deployment-standalone.tar.gz"
            echo "Found package in /tmp/"
          # Check for package in home directory
          elif [ -f "$HOME/deployment-standalone.tar.gz" ]; then
            DEPLOYMENT_PACKAGE="$HOME/deployment-standalone.tar.gz"
            echo "Found package in home directory"
            echo "Note: Extracting directly from home directory (not moving to /tmp/ due to space constraints)"
          else
            echo "❌ Deployment package not found in /tmp/ or home directory"
            echo "Searching for package..."
            find /tmp "$HOME" -name "deployment-standalone.tar.gz" -type f 2>/dev/null | head -5 || true
            exit 1
          fi
          
          echo "Using package: $DEPLOYMENT_PACKAGE"
          echo "Package size: $(du -h "$DEPLOYMENT_PACKAGE" | cut -f1)"
          
          echo "Verifying package integrity..."
          if ! tar -tzf "$DEPLOYMENT_PACKAGE" > /dev/null 2>&1; then
            echo "❌ Deployment package is corrupted or invalid"
            exit 1
          fi
          
          echo "Extracting deployment package from $DEPLOYMENT_PACKAGE..."
          tar -xzf "$DEPLOYMENT_PACKAGE"
          
          # Clean up package file after extraction (if in home directory to save space)
          if [ "$DEPLOYMENT_PACKAGE" != "/tmp/deployment-standalone.tar.gz" ]; then
            echo "Cleaning up package file from home directory..."
            rm -f "$DEPLOYMENT_PACKAGE" || true
          fi

          # 7a. Restore or merge data directory
          echo "=== Restoring data directory ==="
          echo "BACKUP_DATA_DIR: ${BACKUP_DATA_DIR:-'not set'}"
          if [ -n "$BACKUP_DATA_DIR" ] && [ -d "$BACKUP_DATA_DIR/data" ]; then
            echo "Restoring existing data directory from: $BACKUP_DATA_DIR"
            if [ -d "data" ]; then
              echo "Merging data directories..."
              # 既存のデータベースファイルを保持しつつ、新しいファイルを追加
              if [ -d "${BACKUP_DATA_DIR}/data/contents" ]; then
                if [ ! -d "data/contents" ]; then
                  echo "Creating contents directory..."
                  sudo mkdir -p data/contents || true
                fi
                echo "Merging contents databases..."
                while IFS= read -r db_file; do
                  if [ -n "$db_file" ] && [ -f "$db_file" ]; then
                    db_filename=$(basename "$db_file")
                    if [ ! -f "data/contents/$db_filename" ]; then
                      sudo cp "$db_file" "data/contents/$db_filename" || true
                    fi
                  fi
                done < <(find "${BACKUP_DATA_DIR}/data/contents" -name "*.db" -type f 2>/dev/null)
              fi
            else
              sudo cp -r "${BACKUP_DATA_DIR}/data" data || true
            fi
            sudo chown -R $USER:www-data data || true
          fi
          
          # Ensure data directory exists
          if [ ! -d "data" ]; then
            echo "⚠️  Warning: data directory not found in deployment package"
            sudo mkdir -p data
            sudo chown $USER:www-data data
          fi
          
          # Verify data directory contents
          echo "=== Data directory verification ==="
          echo "Data directory status:"
          ls -la data/ 2>/dev/null || echo "Data directory is empty or inaccessible"
          
          if [ -d "data/contents" ]; then
            echo "Contents directory found"
            DB_COUNT=$(find data/contents -name '*.db' -type f 2>/dev/null | wc -l 2>/dev/null || printf '0')
            echo "Number of database files: $DB_COUNT"
            if [ "$DB_COUNT" -gt 0 ] 2>/dev/null; then
              echo "Database files:"
              find data/contents -name '*.db' -type f 2>/dev/null | head -10 || true
            fi
          else
            echo "⚠️  Warning: contents directory not found"
          fi
          

          # 8. Verify deployment
          if [ ! -f "server.js" ] || [ ! -f ".next/BUILD_ID" ]; then
            echo "❌ Deployment verification failed"
            exit 1
          fi

          echo "✅ Files extracted successfully"
          BUILD_ID_VALUE="unknown"
          if [ -f ".next/BUILD_ID" ]; then
            BUILD_ID_VALUE="$(cat .next/BUILD_ID 2>/dev/null || echo 'unknown')"
          fi
          echo "BUILD_ID: ${BUILD_ID_VALUE}"
          echo "Deployment info:"
          if [ -f "deployment-info.json" ]; then
            cat deployment-info.json
          else
            echo "⚠️  Warning: deployment-info.json not found"
          fi

          # 9. Set up environment
          cat > .env.production.local << ENV_EOF
          RESEND_API_KEY=${{ secrets.RESEND_API_KEY }}
          RECAPTCHA_SECRET_KEY=${{ secrets.RECAPTCHA_SECRET_KEY }}
          NEXT_PUBLIC_SITE_URL=${{ secrets.NEXT_PUBLIC_SITE_URL }}
          NODE_ENV=production
          PORT=3000
          ENV_EOF

          # 10. Quick test of standalone server
          echo "Testing standalone server..."
          TEST_PID=""
          if command -v timeout >/dev/null 2>&1; then
            timeout 30 node server.js &
            TEST_PID=$!
          else
            node server.js &
            TEST_PID=$!
          fi

          sleep 15

          if [ -n "$TEST_PID" ] && kill -0 "$TEST_PID" 2>/dev/null; then
            echo "✅ Server startup successful"
            
            # Test endpoints
            curl -f -s http://localhost:3000/ > /dev/null 2>&1 && echo "✅ Home page responding" || echo "⚠️  Home page not responding"
            
            curl -f -s http://localhost:3000/api/health > /dev/null 2>&1 && echo "✅ Health check responding" || echo "⚠️  Health check not responding"
            
            kill "$TEST_PID" 2>/dev/null || true
            sleep 3
          else
            echo "❌ Server startup failed"
            exit 1
          fi

          # 11. Start with PM2
          echo "Starting application with PM2..."
          NODE_ENV=production pm2 start server.js --name "yusuke-kim" --env production
          pm2 save
          pm2 startup systemd -u $USER --hp /home/$USER || echo "PM2 startup already configured"

          # 12. Final health check
          sleep 10

          echo "=== Final Health Check ==="
          if pm2 status | grep -q "yusuke-kim.*online"; then
            echo "✅ Application is running"
            
            # Multiple endpoint tests
            ENDPOINTS=("/" "/api/health" "/portfolio/gallery/all")
            
            for endpoint in "${ENDPOINTS[@]}"; do
              if curl -f -s -o /dev/null -w "%{http_code}" "http://localhost:3000${endpoint}" | grep -q "200\|304"; then
                echo "✅ ${endpoint} - OK"
              else
                echo "⚠️ ${endpoint} - Failed"
              fi
            done
          else
            echo "❌ Application is not running properly"
            pm2 logs yusuke-kim --lines 50
            exit 1
          fi

          echo "=== Deployment completed successfully ==="
          STANDALONE_DEPLOY

      - name: Verify deployment
        run: |
          echo "Waiting for application to stabilize..."
          sleep 15

          echo "=== Testing service endpoints on remote host (loopback via SSH) ==="
          ENDPOINTS=("/" "/api/health" "/portfolio/gallery/all")
          for endpoint in "${ENDPOINTS[@]}"; do
            HTTP_CODE=$(ssh deploy-server "curl -s -o /dev/null -w '%{http_code}' http://localhost:3000${endpoint}")
            if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "304" ]; then
              echo "✅ ${endpoint} - OK (HTTP $HTTP_CODE)"
            else
              echo "❌ ${endpoint} - Failed (HTTP $HTTP_CODE)"
              exit 1
            fi
          done

          echo ""
          echo "=== Testing external endpoints (public access) ==="
          EXTERNAL_ENDPOINTS=("/" "/api/health" "/portfolio/gallery/all")
          EXTERNAL_ERRORS=0
          for endpoint in "${EXTERNAL_ENDPOINTS[@]}"; do
            URL="https://yusuke-kim.com${endpoint}"
            # curl with timeout and error handling
            CURL_EXIT=0
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 --connect-timeout 5 "${URL}" 2>&1) || CURL_EXIT=$?
            
            if [ "$CURL_EXIT" -ne 0 ]; then
              echo "⚠️ ${URL} - Connection failed (curl exit code: $CURL_EXIT)"
              EXTERNAL_ERRORS=$((EXTERNAL_ERRORS + 1))
              continue
            fi
            
            if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "304" ]; then
              echo "✅ ${URL} - OK (HTTP $HTTP_CODE)"
            elif [ -z "$HTTP_CODE" ] || [ "$HTTP_CODE" = "000" ]; then
              echo "⚠️ ${URL} - No response (possible timeout or connection issue)"
              EXTERNAL_ERRORS=$((EXTERNAL_ERRORS + 1))
            else
              echo "⚠️ ${URL} - Failed (HTTP $HTTP_CODE)"
              EXTERNAL_ERRORS=$((EXTERNAL_ERRORS + 1))
            fi
          done
          
          if [ "$EXTERNAL_ERRORS" -gt 0 ]; then
            echo ""
            echo "⚠️ Warning: $EXTERNAL_ERRORS external endpoint(s) failed. This may be due to:"
            echo "  - DNS propagation delay"
            echo "  - Network connectivity issues from GitHub Actions"
            echo "  - Firewall or security group restrictions"
            echo "  - SSL certificate issues"
            echo ""
            echo "Internal endpoints are working correctly, so the deployment is likely successful."
            echo "Please verify external access manually if needed."
          else
            echo ""
            echo "✅ All external endpoints are accessible!"
          fi

      - name: Cleanup
        if: always()
        run: |
          ssh deploy-server << 'CLEANUP'
          # Remove temporary files
          rm -f /tmp/deployment-standalone.tar.gz

          # Clean old backups (this is a safety net, main cleanup happens before backup creation)
          # Keep only the last 2 backups
          BACKUP_KEEP_COUNT=2
          if [ -d "/var/www/backups" ]; then
            cd /var/www/backups
            echo "Final cleanup of old backups (keeping last ${BACKUP_KEEP_COUNT})..."
            
            # Clean all backup types
            for pattern in "yusuke-kim-*" "yusuke-kim-data-*" "data-*"; do
              OLD_BACKUPS=$(ls -1t $pattern 2>/dev/null | tail -n +$((BACKUP_KEEP_COUNT + 1)) || true)
              if [ -n "$OLD_BACKUPS" ]; then
                echo "$OLD_BACKUPS" | while read -r backup; do
                  if [ -n "$backup" ]; then
                    echo "  Removing: $backup"
                    sudo rm -rf "$backup"
                  fi
                done
              fi
            done
            
            echo "✅ Old backups cleaned"
            echo "Remaining backups:"
            ls -lh /var/www/backups/ | head -10 || true
            echo "Total backup size: $(du -sh /var/www/backups 2>/dev/null | cut -f1 || echo 'unknown')"
          fi
          CLEANUP

      - name: Fetch deployment log
        if: always()
        run: |
          LOG_FILE=$(ssh deploy-server "ls -t /tmp/deploy-standalone-*.log 2>/dev/null | head -n 1") || true
          if [ -n "$LOG_FILE" ]; then
            echo "=== Remote deployment log: $LOG_FILE ==="
            ssh deploy-server "tail -n 200 $LOG_FILE" || true
          else
            echo "No deployment log found on remote server"
          fi
